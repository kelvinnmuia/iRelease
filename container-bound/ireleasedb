import Dexie from "dexie";

// Your existing interface
export interface ReleaseRecord {
  id?: number;
  Release_id: string;
  System_name: string;
  System_id: string;
  Release_version: string;
  Iteration: number;
  Release_description: string;
  Functionality_delivered: string;
  Date_delivered_by_vendor: string;
  Notification_date_for_deployment_to_test: string;
  Date_deployed_to_test: string;
  Date_of_test_commencement: string;
  Date_of_test_completion: string;
  Date_deployed_in_production: string;
  Time_taken_to_deploy_after_delivery: number;
  Time_taken_to_start_testing_after_deployment: number;
  Time_taken_to_complete_testing: number;
  Time_taken_to_deploy_after_completing_testing: number;
  Test_status: string;
  Deployment_status: string;
  Outstanding_issues: string;
  Comments: string;
  Type_of_release: string;
  Month: string;
  Test_plan_creation_date: string;
  Financial_year: string;
  Test_plan_SLA_days: number;
  Date_updated: string;
  Updated_by: string;
  lastSynced?: number;
}

// Simple database with just releases table for now
export const db = new Dexie("ireleasedb");
db.version(1).stores({
  releases: "++id, Release_id, System_name, Test_status, lastSynced"
});

// Type the database
export const ireleaseDB = db as Dexie & {
  releases: Dexie.Table<ReleaseRecord, number>;
};

/**
 * Check if Dexie is empty
 */
export async function isDexieEmpty(): Promise<boolean> {
  const count = await ireleaseDB.releases.count();
  return count === 0;
}

/**
 * Find and load JSON file
 */
export async function loadJSONData(): Promise<any> {
  try {
    console.log('üì• Loading JSON data...');
    
    // First try: Direct import (works with Vite/Webpack)
    try {
      // Adjust the path based on your project structure
      const jsonData = await import('../frontend/irelease-dashboard/public/data/releases.json');
      console.log('‚úÖ JSON loaded via import');
      return jsonData.default || jsonData;
    } catch (importError) {
      console.log('Import failed, trying fetch...');
    }
    
    // Second try: Fetch from public folder
    const basePath = window.location.origin;
    const fetchPaths = [
      `${basePath}/data/releases.json`,
      '/data/releases.json',
      './data/releases.json',
      'data/releases.json'
    ];
    
    for (const path of fetchPaths) {
      try {
        console.log(`üîÑ Trying path: ${path}`);
        const response = await fetch(path);
        
        if (response.ok) {
          const data = await response.json();
          console.log(`‚úÖ JSON loaded from: ${path}`);
          return data;
        }
      } catch (fetchError) {
        console.log(`‚ùå Path ${path} failed:`, fetchError.message);
        continue;
      }
    }
    
    throw new Error('Could not load JSON from any path');
    
  } catch (error) {
    console.error('‚ùå Failed to load JSON:', error);
    throw error;
  }
}

/**
 * Seed data from static JSON file
 */
export async function seedFromStaticJSON(): Promise<{success: boolean; count: number}> {
  try {
    console.log('üì• Seeding data from static JSON...');
    
    // Load JSON data
    const jsonData = await loadJSONData();
    
    // Validate JSON structure
    if (!jsonData || !Array.isArray(jsonData.releases)) {
      console.error('Invalid JSON structure:', jsonData);
      throw new Error('JSON data must have a "releases" array');
    }
    
    const now = Date.now();
    const releasesToStore = jsonData.releases.map((release: any) => ({
      ...release,
      lastSynced: now
    }));
    
    console.log(`üìä Found ${releasesToStore.length} releases in JSON`);
    
    // Clear existing data
    await ireleaseDB.releases.clear();
    console.log('üóëÔ∏è Cleared existing data');
    
    // Store new data
    await ireleaseDB.releases.bulkAdd(releasesToStore);
    console.log('üíæ Stored releases in Dexie');
    
    // Verify storage
    const storedCount = await ireleaseDB.releases.count();
    console.log(`‚úÖ Seeded ${storedCount} releases`);
    
    // Log first record for verification
    if (storedCount > 0) {
      const firstRecord = await ireleaseDB.releases.limit(1).toArray();
      console.log('üìù First record sample:', {
        Release_id: firstRecord[0].Release_id,
        System_name: firstRecord[0].System_name,
        Test_status: firstRecord[0].Test_status
      });
    }
    
    return {
      success: true,
      count: storedCount
    };
    
  } catch (error) {
    console.error('‚ùå Failed to seed from JSON:', error);
    return {
      success: false,
      count: 0
    };
  }
}

/**
 * Initialize database - seed if empty
 */
export async function initializeDatabase(): Promise<{seeded: boolean; count: number}> {
  console.log('üîÑ Initializing database...');
  
  const empty = await isDexieEmpty();
  
  if (empty) {
    console.log('Dexie is empty, seeding from static JSON...');
    const result = await seedFromStaticJSON();
    return {
      seeded: result.success,
      count: result.count
    };
  } else {
    const count = await ireleaseDB.releases.count();
    console.log(`‚úÖ Dexie already has ${count} releases`);
    
    // Log sample data
    if (count > 0) {
      const sample = await ireleaseDB.releases.limit(1).toArray();
      console.log('üìä Sample record:', {
        id: sample[0].id,
        Release_id: sample[0].Release_id,
        Test_status: sample[0].Test_status
      });
    }
    
    return {
      seeded: false,
      count
    };
  }
}

/**
 * Get all releases from Dexie
 */
export async function getAllReleases(): Promise<ReleaseRecord[]> {
  return await ireleaseDB.releases.toArray();
}

/**
 * Get single release by ID
 */
export async function getReleaseById(releaseId: string): Promise<ReleaseRecord | undefined> {
  return await ireleaseDB.releases
    .where('Release_id')
    .equals(releaseId)
    .first();
}

/**
 * Get releases by status
 */
export async function getReleasesByStatus(status: string): Promise<ReleaseRecord[]> {
  return await ireleaseDB.releases
    .where('Test_status')
    .equals(status)
    .toArray();
}

/**
 * Get total count
 */
export async function getTotalCount(): Promise<number> {
  return await ireleaseDB.releases.count();
}

/**
 * Get stats for dashboard
 */
export async function getDashboardStats() {
  const allReleases = await getAllReleases();
  const total = allReleases.length;
  
  const inTesting = allReleases.filter(r => r.Test_status === "In Testing").length;
  const passed = allReleases.filter(r => r.Test_status === "Passed").length;
  const failed = allReleases.filter(r => r.Test_status === "Failed").length;
  
  console.log('üìä Dashboard stats:', { total, inTesting, passed, failed });
  
  return {
    total,
    inTesting,
    passed,
    failed
  };
}

/**
 * Clear all data (for testing/reset)
 */
export async function clearAllData(): Promise<void> {
  console.log('üóëÔ∏è Clearing all data...');
  return await ireleaseDB.releases.clear();
}

/**
 * Force reseed database
 */
export async function forceReseed(): Promise<{success: boolean; count: number}> {
  console.log('üîÑ Force reseeding database...');
  return await seedFromStaticJSON();
}